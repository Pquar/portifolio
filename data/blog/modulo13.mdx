---
title: '13- Banco de Dados Relacional'
date: '2024-05-18'
lastmod: '2024-05-18'
tags: ['agregadas', 'consultas', 'crud', 'sql', 'acid', 'agrupamento']
summary: 'Quase tudo oque precisa saber sobre banco de dados'
images: ['/static/images/banners/full-stack.png']
authors: ['default']
---

# ACID

**ATOMATICIDADE‚Üí** Controle sobre inicio e fim da transa√ß√£o, √© a garantia que todo o bloco de transa√ß√µes foi executado integralmente

**CONSISTENCIA‚Üí** Est√° ligada a essas informa√ß√µes serem coerentes e representarem bem a realidade

**ISOLAMENTO‚Üí** √â a separa√ß√£o das modifica√ß√µes de recursos ou de dados feitas por transa√ß√µes diferentes.

**DURABILIDADE‚Üí** Preserva√ß√£o dos dados ap√≥s as opera√ß√µes terem sido realizadas.

# SQL - Structured Query Language.

Conceitos B√°sicos e Estrutura do Banco de Dados Relacional

**DQL:** Data query Language ou Linguagem de consulta de dados EX:SELECT

**DML:** Data manipulation language ou Linguagem de manipula√ß√£o de dados EX:INSERT, UPDATE E DELETE

**DDL:** Data definition language ou lingugagem de Defini√ß√£o de dados EX:CREATE ALTER, DROP

**Modelagem de Bancos de Dados**

**MER:** modelo Entidade-Relacionamento.

**DER:** Diagramas Entidade-Relacionamento.

[draw.io](http://draw.io)

**Cardinalidades:**

**1..1:** (um para um) ‚Üí N√£o tem necessidade de mais tabelas.

**1..n ou 1..*:** (um para muitos) ‚Üí o lado que tem **muitos** recebe o **um** como chave estrangeira.

**n..n ou **..*:*** (muito para muitos) ‚Üí cria-se uma nova tabela com as Chaves-Primarias de Cada Tabela.

**Ex:**


<figure>
<img src="/static/images/modulo/models.png" alt="Modelo client-server" className="max-w-full px-12"/>
<figcaption className='text-center'><a href="#"> Fonte: Imagem Retirada da Internet</a></figcaption>
</figure>


**Modelagem Conceitual:**

**Modelagem Logica:**


<figure>
<img src="/static/images/modulo/model-conceitual.png" alt="Modelo client-server" className="max-w-full px-12"/>
<figcaption className='text-center'><a href="#"> Fonte: Cleiton A Moura</a></figcaption>
</figure>



<figure>
<img src="/static/images/modulo/model-fisico.png" alt="Modelo client-server" className="max-w-full px-12"/>
<figcaption className='text-center'><a href="#"> Fonte: Cleiton A Moura</a></figcaption>
</figure>


**Modelagem F√≠sica**

```sql
-- CREATE DATABASE locadora_de_fitas

-- Tabelas Primarias (Chave primaria)
CREATE TABLE ATORES (
    idAtor SERIAL PRIMARY KEY NOT NULL,
    nomeReal VARCHAR(120) NOT NULL,
    dataNasc DATE NOT NULL
);

CREATE TABLE CATEGORIAS (
    idCategoria SERIAL PRIMARY KEY NOT NULL,
    nome VARCHAR(120) NOT NULL
);

-- Tabelas Secundaria(Chave primaria e estrangeira)
CREATE TABLE CLIENTES (
    idClient SERIAL PRIMARY KEY NOT NULL,
    nome VARCHAR(120) NOT NULL,
    idAtor INTEGER NOT NULL,
    FOREIGN KEY (idAtor) REFERENCES ATORES (idAtor)
);

CREATE TABLE DEPENDENTES (
    idClient INTEGER PRIMARY KEY NOT NULL ,
    grau_parentesco VARCHAR(20) NOT NULL,
    FOREIGN KEY (idClient) REFERENCES CLIENTES (idClient)
);

CREATE TABLE FILMES (
    idFilme SERIAL PRIMARY KEY NOT NULL,
    titulo VARCHAR(120) NOT NULL,
    idCategoria INTEGER NOT NULL,
    FOREIGN KEY (idCategoria) REFERENCES CATEGORIAS (idCategoria)
);

CREATE TABLE FITAS (
    idFilme SERIAL PRIMARY KEY NOT NULL,
    numero INTEGER NOT NULL,
    FOREIGN KEY (idFilme) REFERENCES FILMES (idFilme)
);

CREATE TABLE ESTRELA (
    idFilme INTEGER PRIMARY KEY NOT NULL,
    idAtor INTEGER NOT NULL,
    FOREIGN KEY (idFilme) REFERENCES FILMES (idFilme),
    FOREIGN KEY (idAtor) REFERENCES ATORES (idAtor)
);

CREATE TABLE LOCACAO (
    numero INTEGER PRIMARY KEY NOT NULL,
    idClient INTEGER  NOT NULL,
    dataLocacao DATE NOT NULL,
    dataDevolucacao DATE NOT NULL,
    FOREIGN KEY (idClient) REFERENCES CLIENTES (idClient)
    FOREIGN KEY (numero) REFERENCES FITAS (numero)
);
```

Configura√ß√£o do Ambiente:

Postgress; MariaDB;

**Tipos de dados e custo de armazenamento**

- Tabelas, Colunas e Registros

**Tabelas:** O banco de dados e organizado por tabelas que possuem linha e colunas, cada tabela precisa-se ter um nome √∫nico e uma chave-√önica para identificar cada linha.

**Colunas:** Representar um atributo especifico que guardam um tipo de dado especifico: `texto, numero, data` entre outros.

**Registro:** S√£o os dados dentro da tabela.

**Restri√ß√µes de Valor:**

NOT NULL ‚Üí Valor n√£o pode ser nulo 
UNIQUE ‚Üí Valor tem que ser unico
DEFAULT ‚Üí Define um valor padr√£o se n√£o for passado valor algum

Chaves-Primarias e Estrangeiras

Primaria ‚Üí Valor unico na tabela, ele que pode indentificar o registro. ex: CPF, id.

Estrangeira ‚Üí Chave primaria de outra tabela para futuros relacionamento entre tabelas.

| Tipos de dados | Dentro do SQL |
| --- | --- |
| Texto | TEXT |
| Inteiros | INTEGER/INT |
| Decimal/Numerico | Decimal/ Numeric |
| Caractere/Varchar | Character/Varchar |
| Data/Hora | Data/Time |
| Booleano | Boolean |

Auto Incremento‚Üí Informa√ß√µes que incremente automaticamente ex: POSTGRES=SERIAL(Comando come√ßa em 1 e incremente +1 para cada adi√ß√£o de um novo registro)

phpMyAdmin=AUTO_INCREMENT.

# Criar uma Tabela

```sql
-- Como criar uma Tabela
CREATE TABLE NomeTabela{
	id SERIAL NOT NULL,
	nome VARCHAR(255) NOT NULL COMMENT "NOME",
	data DATE COMMENT "DATA"
}
```

```sql
--Como n√£o criar uma tabela
CREATE TABLE NomeTabela{
	id INTEGER,
	nome TEXT,
	data DATETIME --data e hora
}
```

# CRUD

**Create ‚Üí `INSERT INTO`**

**Read ‚Üí `SELECT`**

**Update ‚Üí `UPDATE`**

**Delete ‚Üí `DELETE`**

```sql
--CREATE
INSERT INTO nome_Tabela (colunaInt,colunaTexto02) VALUES (1,"valorcolunar2")

--Exemplos
-- PROJETOS
INSERT INTO PROJETOS (descricao, categorias) VALUES ('Projeto 1', 'Desenvolvimento, front-end, back-end, banco de dados');
-- CATEGORIAS
INSERT INTO CATEGORIAS (tipoProjeto, descricao, horasNecessarias) VALUES ('Banco de dados', 'Desenvolvimento de banco de dados', INTERVAL '46 hours');
-- FUNCIONARIO
INSERT INTO FUNCIONARIO (nome, funcao) VALUES ('Jo√£o', 'Desenvolvedor');
-- CLEINTES
INSERT INTO CLIENTES (cpnj_cpf, investimento, nomeEmpresa) VALUES ('123456789', 10000.00, 'Empresa 1');

--Read
SELECT (informacoes vc quer) FROM (de que tabela?) WHERE (CONDI√á√ïES) AND (JUN√á√ÉO)
-- 1 Retorna todo os projetos de um cliente
SELECT cl.idcliente ,ct.idprojetos, p.descricao, p.categorias FROM projetos p, clientes cl, contratos ct 
WHERE cl.idcliente=3 AND ct.idcliente=cl.idcliente AND p.idprojetos=ct.idprojetos

--Update
INSERT INTO nome_Tabela SET (colunaInt=1,colunaTexto02="novo texto") WHERE colunaInt=1
-- o where e a condi√ß√£o para que seja um registro unico e n√£o atualizar todos dados da tabela

--Delete
DELETE FROM nome_tabela WHERE colinaInt=1
-- o where e a condi√ß√£o para que seja deletado um unico registro e n√£o deletar todos dados da tabela

```

### Alterando e Excluindo Tabelas

`Alter Table` ‚Üí Alterar informa√ß√µes da tabela ou excluir, modificar restri√ß√µes, indices, renomear tabelas dentre outros.

`Drop Table` ‚Üí Deleta a tabela üëø

```sql
--Alterar Tabela
ALTER TABLE nome_tabela RENAME novatabela;
-- Dependo do dado da coluna o comando pode ser diferente
ALTER TABLE nome_tabela MODIFY COLUMN colunaVAR150 VARCHAR(255);

--Deletar Tabela
DROP TABLE nome_tabela;
```

### Mudando informa√ß√µes Existente Cuidados

ON DELETE ‚Üí Especifica o que acontecer com o registros dependentes quando um registro ‚ÄúPAI‚Äù e exclu√≠do.

ON UPDATE ‚Üí Define o comportamento dos registros dependentes quando um registro ‚ÄúPai‚Äù e alterado.

CASCADE ‚Üí

SET NULL ‚Üí

SET DEFAULT ‚Üí

RESTRICT ‚Üí

# **Normaliza√ß√£o de dados**

Inconsist√™ncia dos dados? como resolver isso e so Normalizar a entrada de dados.

Formular os dados que entram por exemplo: **CPF** e `String` ou `int`? Voc√™ vai dizer e adotar como padr√£o.

6FN ‚Üí tem como objetivo¬†**eliminar a redund√¢ncia**

1FN ‚Üí ATOMICIDADE DE DADOS

2FN ‚Üí Todos atributos n√£o chaves devem depender da Chave-Primaria.

3FN ‚Üí Nenhum coluna que n√£o e chave pode depender de outra coluna que n√£o e Chave

```sql
UPDATE nometabela SET rua= SUBTRING_INDEX(SUBSTRING_INDEX(endereco, ',',1),',',-1);
```

# Consultas com jun√ß√µes e Sub Consultas

inner join,  

left join

Right join

Full Join

## Sub-Consultas

```sql
SELECT * FROM nomeTabela WHERE id NOT IN (SELECT id_coluna FROM tabela2);
```

- Fun√ß√µes agregadas e agrupamento de resultados
- √çndices

# Fun√ß√µes Agregadas

COUNT ‚Üí Conta o numero de registros

SUM ‚Üí Soma os valores de uma coluna numerica

AVG ‚Üí Calcula  amedia dos valores de um coluna numerica

MIN ‚Üí REtorna o valor minimo de uma coluna

MAX ‚Üí Retorna o valor maximo de uma coluna

# Agrupamento de Resultados

group by 

# Indices de Buscas

idx_index

**Editando e removendo dados** 

**Permissionamento e Views**

**√çndices**

# View

```sql
CREATE VIEW
CREATE MATELIZE VIEW
```

# Stored Procedures

Pode ser armazenados de forma compilada no catalogo do SGBD; 

Procedures n√£o retorna um valor para o usuario (fun√ß√£o retorna valor para o usuario)

Procedures ‚Üí Rotina para o SGBD n√£o precisa retorna nada

Function ‚Üí Rotina que retorna-ra uma valor para o usuario.

Salva em cache do banco

O codigo e armazenado na stored procedures no banco

Aumenta a manipula√ß√£o de tipos de dados complexos usados pelos procedimentos

Aumenta a seguran√ßa por limitar o acesso de alguns usuarios ao BD

```sql
Call
```

Desvantagem: Quando voce ultiliza mais de 1 SGBD, 

Podem ser implementadas de varios modos; Lingugagens n√£o-procedurais;

Procedurais ‚Üí Seguem o padr√£o SQL/PSM(ISO Starndard);

Linguagens externas geralmente C++;

Implementa√ß√£o (lingugagem procedural)

SQL/PSM ‚Üí Persistent Stored Modules

Cada SGBD ofere sua propria linguagem (Oracle Pl/SQL)

PostgreSQL ‚Üí SPs n√£o retornam valores, e plpgsql

PostgreSQL 11 introduziu o comando `CREATE PROCEDURE` com suporte a transa√ß√µes.

Diferan√ßa entre Funciton e Procedure

Funciton ‚Üí Chamada parte de um query Select, n√£o permite realizar commit ou rollback;

Procedure ‚Üí Chamada de modo isolado usando call; Pode realizar commit ou rollback;

```sql
CREATE [OR REPLACE] PROCEDURE
	name ([[argname] argtyoe[, ...]])
LANGUAGE plpgsql
AS &&
	DECLARE
	  --Declara√ßao variavel
	BEGIN
		--Corpo da stored procedure
	END;
$$;

CALL procedure_name (params, 'Rua dos Corsarios 120', '47 99999-9999');
```

```sql
--SQL
CREATE OR REPLACE PROCEDURE p_gravaEntregadores (a_nome VARCHAR(40)),
				a_endereco VARCHAR(50), a_celular VARCHAR(50), a_celular VARCHAR(15))
LANGUAGE sql
AS $$
	INSERT INTO funcionarios (funcionario, endereco, cargo,celular)
			VALUES (a_nome, a_endereco, 'Entregador', a_celular);
END
$$;
--PLPGSQL
CREATE OR REPLACE PROCEDURE p_gravaEntregadores (a_nome VARCHAR(40)),
				a_endereco VARCHAR(50), a_celular VARCHAR(50), a_celular VARCHAR(15))
LANGUAGE plpgsql
AS $$
BEGIN
	INSERT INTO funcionarios (funcionario, endereco, cargo,celular)
			VALUES (a_nome, a_endereco, 'Entregador', a_celular);
END
$$;
```

```sql
CALL p_gravaEntregadores ('Bruno', 'Rua dos Corsarios 120', '47 99999-9999');
```

**Modo dos argumentos**

| IN | (default) indica que o par√¢metro e de entrada. |
| --- | --- |
| OUT | Indica que o par√¢metro e de sa√≠da. N√£o permitido em procedures. |
| INOUT | Indica que o par√¢metro e de entrada e sa√≠da. |
| VARIADIC | Um Array de um tipo de dado de entrada. Deve ser o ultimo argumento. ex: VARIADIC INTEGER[] |

```sql
CREATE OR REPLACE PROCEDURE p_gravaEntregadores (IN a_nome VARCHAR(40)),
				a_endereco VARCHAR(50), a_celular VARCHAR(50), a_celular VARCHAR(15))

CREATE OR REPLACE PROCEDURE p_gravaEntregadores (OUT a_nome VARCHAR(40)),
				a_endereco VARCHAR(50), a_celular VARCHAR(50), a_celular VARCHAR(15))

CREATE OR REPLACE PROCEDURE p_gravaEntregadores (INOUT a_nome VARCHAR(40)),
				a_endereco VARCHAR(50), a_celular VARCHAR(50), a_celular VARCHAR(15))

CREATE OR REPLACE PROCEDURE p_gravaEntregadores (IN a_nome VARCHAR(40)),
				a_endereco VARCHAR(50), a_celular VARCHAR(50), VARIADIC a_celular VARCHAR(15)[])
```

## Sobrescrever Chamada de Procedimentos(ou Fun√ß√µes)

```sql
CREATE OR REPLACE PROCEDURE p_soma (OUT a_va INTEGER, a_vb INTEGER),
LANGUAGE plpgsql
AS $$
	DECLARE resultado INTEGER;
	BEGIN 
BEGIN
	l_resultado = a_va+a_vb;
END
$$;

CREATE OR REPLACE PROCEDURE p_soma (OUT a_va INTEGER, a_vb INTEGER,
																			INOUT a_result INTEGER)
LANGUAGE plpgsql
AS $$
	BEGIN 
BEGIN
	a_resul = a_va+a_vb;
END
$$;

CALL p_soma(1,2);
CALL p_soma(1,2, resultado_armazena);

```

# Banco de Dados n√£o Relacional

NOT Only SQL

N√£o seguem o modelo de tabelas e relacionamento( pode ser chave valor)

- Alto volume dad dados
- Alta escalabilidade.
- Alta Flexibilidade na estrutura de dados
- Toler√¢ncia a falhas.

Comumente utilizados onde o cen√°rio de consist√™ncia imediata dos dados n√£o e critica.

# Tipos

- key-values
- Documentos
- Colunas
- Grafos
- ‚Ä¶

Key-Value‚Üí Armazenamento por chave valores

Exemplos: Redis, Riak, Amazon DynamoDB.

Document ‚Üí Armazenam dados em documentos semiestrturados(JSON).

Exemplos: MongoDB, Counchbase, Apache, CouchDB.

Colunas ‚Üí Armazenam em formato d colunas, permite alta escalabilidade e eficiencia em determinados tipos de consultas 

Exemplos: Apache Cassandra, ScyllaDB, HBase

Grafo ‚Üí Armazem e consultar dados interconectados, onde os relacionamentos entre os dados s√£o t√£o importante quanto os proprios dados

Exemplos: Neo4j, Amazon Neptune, JanusGraph.

# MongoDB

DataBase ‚Üí 

Cole√ß√£o ‚Üí  Agrupamento de documentos, N√£o Existe uma estrutura de documento.

OBS: nome de cole√ß√£o devem seguir algumas regras: devem come√ßar com uma letra ou um underscore (_); Podem conter letras, n√∫meros ou underscores; N√£o podem ser vazios; N√£o podem ter mais de 64 bytes de comprimento.

Documentos ‚Üí S√£o armazenados dem BSON(BINARY JSON), que s√£o estruturas flexiveis e semiestruturadas; Cada documento possui um indentificador unico chamado _id; Composto por pares de chaves e valores.

OBS: Tamanho maximo de 16MB; Aninhamento de documentos; Flexibilidade na evolu√ß√£o do esquema;

TIPOS DE DADOS SIMPLES

| STRING |  |
| --- | --- |
| NUMBER |  |
| BOOLEAN |  |
| DATE |  |
| NULL |  |
| OBJECTID |  |

Dados complexos ‚Üí Arrays; Documento Embutido(Embedded Document); Refer√™ncia, GeoJSON;

Estrutura do documento simples

```json
{
	_id: ObjectId(""),
"nome_campo":"valor_campo"
}
```

# Modelagem da estrutura do USUARIO e DESTINOS

jsonformatter.curiousconcept.com

```json
{
	"_id":1,
	"nome": "Cleiton",
	"idade": 23,
	"data_nsc": "2000-05-24",
	"enderecos":{
	"numeros":231,
	"cordenada": [-1.2312,1231.1231]

	}
}
```

# Inner Documents

E comum com MONGOdb a denormalizar os dadospara evitar opera√ß√µes de jun√ß√£o(join) custosas.

```json
{
	"_id":1,
	"nome": "Cleiton",
	"idade": 23,
	"data_nsc": "2000-05-24",
	"enderecos":[
		{
		"numeros":231,
		"cordenada": [-1.2312,1231.1231]
		},
		{
		"numeros":232,
		"cordenada": [-2.2312,1231.1231]
		}
	],
	"parentes": [
			{
				"pai":"ObjectId(123)"
			}
		]
}
```

Dados aninhados s√£o espec√≠ficos para o documento pai; Os dados aninhados s√£o sempre acessados juntamente com o documento pai; A cardinalidade do relacionamento e um-para-muitos(parentes, enderecos);

Se os dados precisam ser consultado e atualizados independentemente do documento pai, e mais adaquedado ultilizar cole√ß√µes separadas.

# Comandos

```json
db.usuarios

findOne({})
findOneAndUpdate({})
findOneAndDelete({})
find({})
UpdateOne({})
UpdateMany({})
deleteOne({})
deleteMany({})

```

Proje√ß√µes ‚Üí Definir quais campos devem ser retornados em uma consulta.

Ordena√ß√£o ‚Üí Ordenar os resutados de uma comnsulta com base em um ou mais campos.

Limita√ß√£o ‚Üí Limitar o numero de documentos retornados em uma consulta.

Pagina√ß√£o ‚Üí find().skip(10).limit(5) ‚Üí skip ‚Üí quanto tempo e para esperar para travez a consulta ‚Üí limit ‚Üí Quanta consultas para travez

# Operadores L√≥gicos

| Operador | Equivalente |
| --- | --- |
| $eq | == |
| $ne | != |
| $gt | > |
| $gte  | >= |
| $it | `<` |
| $in | [] = Range |
| $nin | [] = !not |
| $and |  |
| $or |  |
| $not |  |

Sort ‚Üí Orena√ß√£o (asc, desc)

```json
{idade: {$gt:18}}
{$or:{}}
....
```

# Redis

Sistema de armazenamento de dados em memoria de alto desempenho (resetou os servidor perdeu os dados üï∂Ô∏è)

## Caracter√≠sticas

- Armazenamento em mem√≥ria.
- Estrutura de Dados Vers√°til
- Opera√ß√µes At√¥micas
- Cache de Alto Desempenho
- Pub/Sub (Publica√ß√£o/Assinatura)(Kafka raabitmq) *simplista*

# Principais Comandos

SET ‚Üí Adiciona uma informa√ß√£o 

GET ‚Üí Trazer a informa√ß√£o

DEL ‚Üí Deletar a informa√ß√£o

EXISTS ‚Üí Saber se existe pode voltar null(existe tempo de expira√ß√£o dos dados)

KEYS ‚Üí Trazer as chaves corresponde

INCR 

DECR

```json
set nome "Cleiton"
get nome
set nome1 "C"
keys nome*
del nome "Cleiton"
EXPIRE nome1 10 //10 segundos
TTL nome1 //tempo restante
DECR nome
LPUSH usuario "C" "A" "M" //Array
LRANGE usuario 0 -1
LPUSH usuario "z"
```

[Try Redis](https://try.redis.io/)


# Estrutura de Tabela no Dia a Dia

# Otimiza√ß√£o de Query 